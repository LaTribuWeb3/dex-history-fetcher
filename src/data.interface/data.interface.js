////////////////////////////////////////
/////// THIS IS THE DATA INTERFACE /////
// IT ALLOWS EASY ACCESS TO CSV DATA ///
/// IT SHOULD BE THE ONLY THING USED ///
/// TO ACCESS THE DATA GENERATED BY ////
//////////// BY THE FETCHERS ///////////

const path = require('path');
const fs = require('fs');
const { fnName, roundTo, retry, arrayAverage } = require('../utils/utils');
const { computeParkinsonVolatility } = require('../utils/volatility');
const { ethers } = require('ethers');
const { getBlocknumberForTimestamp } = require('../utils/web3.utils');

const PIVOTS = ['USDC', 'WETH', 'WBTC'];
const ALL_PLATFORMS = ['uniswapv2', 'uniswapv3', 'curve'];
const DATA_DIR = process.cwd() + '/data';



/**
 * Compute the parkinson's volatility for a pair
 * If 'platforms' is undefined, will find the volatility across all platforms (avg)
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {number} daysToAvg the number of days the interval spans
 * 
 */
function getParkinsonVolatilityForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, daysToAvg) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    const label = `${fnName()}[${fromSymbol}/${toSymbol}] [${fromBlock}-${toBlock}] [${platforms.join(',')}]`;

    console.log(`${label}: getting data for all platforms, will average volatility`);
    let data = {};
    for(const platform of platforms) {
        const unifiedData = getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock);
        if(!unifiedData) {
            console.log(`${label}: could not find data on platform ${platform}`);
        } else {
            data[platform] = unifiedData;
        }
    }

    if(Object.keys(data).length == 0) {
        return undefined;
    }

    console.log(`${label}: will compute parkinson volatility from ${Object.keys(data).length} platforms data`);
    const volatilities = [];
    for(const platform of Object.keys(data)) {

        // generate the priceAtBlock object
        const priceAtBlock = {};
        for(const [blockNumber, unifiedData] of Object.entries(data[platform])) {
            priceAtBlock[blockNumber] = unifiedData.price;
        }

        const volatility = computeParkinsonVolatility(priceAtBlock, fromSymbol, toSymbol, fromBlock, toBlock, daysToAvg);
        console.log(`${label}: volatility found for ${platform}: ${roundTo(volatility*100, 2)}%`);
        volatilities.push(volatility);
    }

    // return avg volatility
    const avgVolatility = arrayAverage(volatilities);
    console.log(`${label}: returning volatility from platforms ${Object.keys(data)} of ${roundTo(avgVolatility*100, 2)}%`);
    return avgVolatility;
}

/**
 * Get the slippage map for a pair
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {bool} withJumps 
 */
async function getSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, withJumps) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    // if(withJumps) {
    //     return await getCombinedSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
    // } else {
    //     return await getSimpleSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
    // }
}

function getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock) {
    // try to find the data
    const filename = `${fromSymbol}-${toSymbol}-unified-data.csv`;
    const fullFilename = path.join(DATA_DIR, 'precomputed', platform, filename);
    console.log(`${fnName()}: searching file ${fullFilename}`);
    if(!fs.existsSync(fullFilename)) {
        console.log(`Could not find file ${fullFilename}`);
        return undefined;
    }

    console.log(`${fnName()}: ${fullFilename} found! Extracting data since ${fromBlock} to ${toBlock}`);
    
    const fileContent = fs.readFileSync(fullFilename, 'utf-8').split('\n');
    const unifiedData = {};
    for(let i = 1; i < fileContent.length - 1; i++) {
        const blockNumber = Number(fileContent[i].split(',')[0]);
        if(blockNumber < fromBlock) {
            continue;
        }

        if(blockNumber > toBlock) {
            break;
        }

        const data = extractDataFromUnifiedLine(fileContent[i]);
        unifiedData[data.blockNumber] = {
            price: data.price,
            slippageMap: data.slippageMap
        };
    }

    return unifiedData;
}

function extractDataFromUnifiedLine(line) {
    const splt = line.split(',');
    const blockNumber = splt[0];
    const price = splt[1];
    const slippageMapJson = line.replace(`${blockNumber},${price},`, '');
    const slippageMap = JSON.parse(slippageMapJson);

    return {
        blockNumber: Number(blockNumber),
        price: Number(price),
        slippageMap: slippageMap
    };
}

async function test() {
    const daysToAvg = 180;
    const web3Provider = new ethers.providers.StaticJsonRpcProvider(process.env.RPC_URL);
    const endBlock = await retry((() => web3Provider.getBlockNumber()), []);
    const startBlock = await getBlocknumberForTimestamp(Math.round(Date.now() / 1000) - (daysToAvg * 24 * 60 * 60));
    const base = 'DAI';
    const quote = 'USDC';
    const allVol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, undefined, daysToAvg);
    const univ2Vol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['uniswapv2'], daysToAvg);
    const univ3Vol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], daysToAvg);
    const curve = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['curve'], daysToAvg);

    console.log({allVol}, {univ2Vol}, {univ3Vol}, {curve});
}

test();

module.exports = { getParkinsonVolatilityForInterval, getSlippageMapForInterval };