////////////////////////////////////////
/////// THIS IS THE DATA INTERFACE /////
// IT ALLOWS EASY ACCESS TO CSV DATA ///
/// IT SHOULD BE THE ONLY THING USED ///
/// TO ACCESS THE DATA GENERATED BY ////
//////////// BY THE FETCHERS ///////////

const path = require('path');
const fs = require('fs');
const { fnName, roundTo, retry, arrayAverage } = require('../utils/utils');
const { computeParkinsonVolatility } = require('../utils/volatility');
const { ethers } = require('ethers');
const { getBlocknumberForTimestamp } = require('../utils/web3.utils');
const { computeAggregatedVolumeFromPivot } = require('../utils/aggregator');

const PIVOTS = ['USDC', 'WETH', 'WBTC'];
const ALL_PLATFORMS = ['uniswapv2', 'uniswapv3', 'curve'];
const DATA_DIR = process.cwd() + '/data';

function getDefaultSlippageMap() {
    const slippageMap = {};
    for(let i = 50; i <= 2000; i+=50) {
        slippageMap[i] = 0;
    }
    return slippageMap;
}

/**
 * Compute the parkinson's volatility for a pair
 * If 'platforms' is undefined, will find the volatility across all platforms (avg)
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {number} daysToAvg the number of days the interval spans
 * @return {number} parkinson's volatility
 */
function getParkinsonVolatilityForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, daysToAvg) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    const label = `${fnName()}[${fromSymbol}/${toSymbol}] [${fromBlock}-${toBlock}] [${platforms.join(',')}]`;

    console.log(`${label}: getting data for all platforms, will average volatility`);

    const data = getUnifiedDataForPlatforms(platforms, fromSymbol, toSymbol, fromBlock, toBlock);

    if(Object.keys(data).length == 0) {
        console.log(`${label}: Cannot find volatility, returning 0`);
        return 0;
    }

    console.log(`${label}: will compute parkinson volatility from ${Object.keys(data).length} platforms data`);
    const volatilities = [];
    for(const platform of Object.keys(data)) {

        // generate the priceAtBlock object
        const priceAtBlock = {};
        for(const [blockNumber, unifiedData] of Object.entries(data[platform])) {
            priceAtBlock[blockNumber] = unifiedData.price;
        }

        const volatility = computeParkinsonVolatility(priceAtBlock, fromSymbol, toSymbol, fromBlock, toBlock, daysToAvg);
        console.log(`${label}: volatility found for ${platform}: ${roundTo(volatility*100, 2)}%`);
        volatilities.push(volatility);
    }

    // return avg volatility
    const avgVolatility = arrayAverage(volatilities);
    console.log(`${label}: returning volatility from platforms ${Object.keys(data)} of ${roundTo(avgVolatility*100, 2)}%`);
    return avgVolatility;
}

/**
 * Get unified data for each target platforms
 * @param {string[]} platforms 
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @returns {{[platform: string]: {[blocknumber: number]: {price: number, slippageMap: {[slippageBps: number]: number}}}}
 */
function getUnifiedDataForPlatforms(platforms, fromSymbol, toSymbol, fromBlock, toBlock) {
    const data = {};
    for (const platform of platforms) {
        const unifiedData = getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock);
        if (!unifiedData) {
            console.log(`getUnifiedDataForPlatforms for ${fromSymbol}/${toSymbol}: could not find data on platform ${platform}`);
        } else {
            data[platform] = unifiedData;
        }
    }
    return data;
}

/**
 * Get the average liquidity in a block interval, for X platforms, with or without pivot route jumps
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {bool} withJumps 
 */
function getAverageLiquidityForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, withJumps) {
    const slippageMapForInterval = getSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, withJumps);

    if(!slippageMapForInterval) {
        return getDefaultSlippageMap();
    }

    let dataToUse = slippageMapForInterval[fromBlock];
    const avgSlippageMap = getDefaultSlippageMap();

    let cptValues = 0;
    for(let targetBlock = fromBlock; targetBlock <= toBlock; targetBlock++) {
        cptValues++;
        if(slippageMapForInterval[targetBlock]) {
            dataToUse = slippageMapForInterval[targetBlock];
        }

        for(const slippageBps of Object.keys(dataToUse)) {
            avgSlippageMap[slippageBps] += dataToUse[slippageBps];
        }
    }

    for(const slippageBps of Object.keys(avgSlippageMap)) {
        avgSlippageMap[slippageBps] =  avgSlippageMap[slippageBps] / cptValues;
    }

    return avgSlippageMap;
}

/**
 * Get the slippage map for a pair
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {bool} withJumps 
 */
function getSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, withJumps) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    // with jumps mean that we will try to add pivot routes (with WBTC, WETH and USDC as pivot)
    if(withJumps) {
        const sumSlippageMapsCombined = getCombinedSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
        return sumSlippageMapsCombined;
    } else {
        const sumSlippageMaps = getSimpleSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
        return sumSlippageMaps;
    }
}

/**
 * Get the slippage maps for each blocks of the interval
 * Using WBTC, WETH and USDC as pivot to try to find aggregated volumes
 * example, for UNI->USDC, we will add UNI/USDC volume to UNI->WETH->USDC and UNI->WBTC->USDC volumes
 * Summing the slippage map for each platforms
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[]} platforms 
 * @returns {{[blocknumber: number]: {[slippageBps: number]: number}}}
 */
function getSimpleSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms) {
    const blocksSlippageMaps = {};
    const data = getUnifiedDataForPlatforms(platforms, fromSymbol, toSymbol, fromBlock, toBlock);
    for(const platform of Object.keys(data)) {
        for(const [blockNumber, platformData] of Object.entries(data[platform])) {
            if(!blocksSlippageMaps[blockNumber]) {
                blocksSlippageMaps[blockNumber] = getDefaultSlippageMap();
            }

            for(const slippageBps of Object.keys(platformData.slippageMap)) {
                const slippageToAdd = platformData.slippageMap[slippageBps];
                blocksSlippageMaps[blockNumber][slippageBps] += slippageToAdd;
            }
        }
    }

    return blocksSlippageMaps;
}

/**
 * Get the slippage maps for each blocks of the interval
 * Summing the slippage map for each platforms
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[]} platforms 
 * @returns {{[blocknumber: number]: {[slippageBps: number]: number}}}
 */
function getCombinedSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms) {
    const blocksSlippageMaps = {};
    const data = getUnifiedDataForPlatforms(platforms, fromSymbol, toSymbol, fromBlock, toBlock);

    const pivotData = getPivotUnifiedData(data, fromSymbol, toSymbol, fromBlock, toBlock);

    for(const platform of Object.keys(data)) {
        for(const [blockNumber, platformData] of Object.entries(data[platform])) {
            if(!blocksSlippageMaps[blockNumber]) {
                blocksSlippageMaps[blockNumber] = getDefaultSlippageMap();
            }

            const aggregatedSlippageMap = structuredClone(platformData.slippageMap);
            // try to add pivot routes
            for(const pivot of PIVOTS) {
                if(fromSymbol == pivot) {
                    continue;
                }
                if(toSymbol == pivot) {
                    continue;
                }

                const segment1DataForBlock = getPivotDataForBlock(pivotData, platform, fromSymbol, pivot, blockNumber);
                
                if(!segment1DataForBlock) {
                    continue;
                }

                const segment2DataForBlock = getPivotDataForBlock(pivotData, platform, pivot, toSymbol, blockNumber);
                if(!segment2DataForBlock) {
                    continue;
                }


                for(const slippageBps of Object.keys(aggregatedSlippageMap)) {
                    const aggregVolume = computeAggregatedVolumeFromPivot(segment1DataForBlock.slippageMap, segment1DataForBlock.price, segment2DataForBlock.slippageMap, slippageBps);
                    aggregatedSlippageMap[slippageBps] += aggregVolume;
                }
            }

            for(const slippageBps of Object.keys(aggregatedSlippageMap)) {
                const slippageToAdd = aggregatedSlippageMap[slippageBps];
                blocksSlippageMaps[blockNumber][slippageBps] += slippageToAdd;
            }
        }
    }

    return blocksSlippageMaps;
}

function getPivotDataForBlock(pivotData, platform, base, quote, blockNumber) {
    if(!pivotData[platform]) {
        return undefined;
    }

    if(!pivotData[platform][base]) {
        return undefined;
    }

    if(!pivotData[platform][base][quote]) {
        return undefined;
    }

    if(!pivotData[platform][base][quote][blockNumber]) {
        return undefined;
    }

    return pivotData[platform][base][quote][blockNumber];
}

function getPivotUnifiedData(data, fromSymbol, toSymbol, fromBlock, toBlock) {
    const pivotData = {};

    for (const platform of Object.keys(data)) {
        for (const pivot of PIVOTS) {
            if (fromSymbol == pivot) {
                continue;
            }
            if (toSymbol == pivot) {
                continue;
            }

            const segment1Data = getUnifiedDataForInterval(platform, fromSymbol, pivot, fromBlock, toBlock);
            if (!segment1Data) {
                continue;
            }

            const segment2Data = getUnifiedDataForInterval(platform, pivot, toSymbol, fromBlock, toBlock);
            if (!segment2Data) {
                continue;
            }

            if (!pivotData[platform]) {
                pivotData[platform] = {};
            }

            if (!pivotData[platform][fromSymbol]) {
                pivotData[platform][fromSymbol] = {};
            }

            if (!pivotData[platform][pivot]) {
                pivotData[platform][pivot] = {};
            }

            pivotData[platform][fromSymbol][pivot] = segment1Data;
            pivotData[platform][pivot][toSymbol] = segment2Data;
        }
    }
    return pivotData;
}

/**
 * Gets the unified data from csv files
 * @param {string} platform 
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @returns {{[blocknumber: number]: {price: number, slippageMap: {[slippageBps: number]: number}}}}
 */
function getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock) {
    // try to find the data
    const filename = `${fromSymbol}-${toSymbol}-unified-data.csv`;
    const fullFilename = path.join(DATA_DIR, 'precomputed', platform, filename);
    // console.log(`${fnName()}: searching file ${fullFilename}`);
    if(!fs.existsSync(fullFilename)) {
        console.log(`Could not find file ${fullFilename}`);
        return undefined;
    }

    // console.log(`${fnName()}: ${fullFilename} found! Extracting data since ${fromBlock} to ${toBlock}`);

    const fileContent = fs.readFileSync(fullFilename, 'utf-8').split('\n');
    const unifiedData = getBlankUnifiedData(fromBlock, toBlock);
    const blocksToFill = Object.keys(unifiedData).map(_ => Number(_));
    let currentIndexToFill = 0;

    for(let i = 1; i < fileContent.length - 2; i++) {
        const blockNumber = Number(fileContent[i].split(',')[0]);

        if(blockNumber > toBlock) {
            break;
        }
        const nextBlockNumber = Number(fileContent[i+1].split(',')[0]);

        if(nextBlockNumber > blocksToFill[currentIndexToFill]) {
            const data = extractDataFromUnifiedLine(fileContent[i]);

            while(nextBlockNumber > blocksToFill[currentIndexToFill]) {
                unifiedData[blocksToFill[currentIndexToFill]] = {
                    price: data.price,
                    slippageMap: data.slippageMap
                };
                currentIndexToFill++;
                if(currentIndexToFill >= blocksToFill.length) {
                    break;
                }
            }
        }
    }

    // if currentIndexToFill == 0, it means that no data was found, return empty
    if(currentIndexToFill == 0) {
        console.log(`Could not find data in file ${fullFilename} since block ${fromBlock}`);
        const latestData = extractDataFromUnifiedLine(fileContent[fileContent.length-2]);
        if(latestData.blockNumber < fromBlock) {
            console.log(`Will use latest data at block ${latestData.blockNumber} to fill unified data`);
            for(const blockNumber of blocksToFill) {
                unifiedData[blockNumber] = {
                    price: latestData.price,
                    slippageMap: latestData.slippageMap
                };
            }

            return unifiedData;
        } else {
            console.log(`Could not find any blocks before ${fromBlock} in file ${fullFilename}`);
            return undefined;
        }
    }
    // if exited before filling every blocks, add last value to all remaining
    const lastFilledIndex = currentIndexToFill-1;
    while(currentIndexToFill < blocksToFill.length) {
        unifiedData[blocksToFill[currentIndexToFill]] = {
            price: unifiedData[blocksToFill[lastFilledIndex]].price,
            slippageMap: unifiedData[blocksToFill[lastFilledIndex]].slippageMap
        };
        currentIndexToFill++;
    }

    return unifiedData;
}

/**
 * This function returns an object preinstanciated with all the blocks that will need to be filled
 * @param {number} startBlock 
 * @param {number} endBlock 
 * @returns {{[blocknumber: number]: {}}}
 */
function getBlankUnifiedData(startBlock, endBlock) {
    const unifiedData = {};
    let currentBlock = startBlock;
    while(currentBlock < endBlock) {
        unifiedData[currentBlock] = {};
        currentBlock+= 50;
    }

    return unifiedData;
}

function extractDataFromUnifiedLine(line) {
    const splt = line.split(',');
    const blockNumber = splt[0];
    const price = splt[1];
    const slippageMapJson = line.replace(`${blockNumber},${price},`, '');
    const slippageMap = JSON.parse(slippageMapJson);

    return {
        blockNumber: Number(blockNumber),
        price: Number(price),
        slippageMap: slippageMap
    };
}

async function testVolatility() {
    const daysToAvg = 180;
    const web3Provider = new ethers.providers.StaticJsonRpcProvider(process.env.RPC_URL);
    const endBlock = await retry((() => web3Provider.getBlockNumber()), []);
    const startBlock = await getBlocknumberForTimestamp(Math.round(Date.now() / 1000) - (daysToAvg * 24 * 60 * 60));
    const base = 'WETH';
    const quote = 'USDC';
    const allVol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, undefined, daysToAvg);
    const univ2Vol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['uniswapv2'], daysToAvg);
    const univ3Vol = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], daysToAvg);
    const curve = getParkinsonVolatilityForInterval(base, quote, startBlock, endBlock, ['curve'], daysToAvg);

    console.log({allVol}, {univ2Vol}, {univ3Vol}, {curve});
}
async function testLiquidity() {
    const daysToAvg = 30;
    const web3Provider = new ethers.providers.StaticJsonRpcProvider(process.env.RPC_URL);
    const endBlock = await retry((() => web3Provider.getBlockNumber()), []);
    const startBlock = await getBlocknumberForTimestamp(Math.round(Date.now() / 1000) - (daysToAvg * 24 * 60 * 60));
    const base = 'UNI';
    const quote = 'WETH';
    // const slippageMaps = getSlippageMapForInterval(base, quote, startBlock, endBlock, undefined, false);
    // const univ2slippageMaps = getSlippageMapForInterval(base, quote, startBlock, endBlock, ['uniswapv2'], false);
    // const univ3slippageMaps = getSlippageMapForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], false);
    // const univ3slippageMapsCombined = getSlippageMapForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], true);
    // // const curveSlippageMaps = getSlippageMapForInterval(base, quote, startBlock, endBlock, ['curve'], false);
    // console.log(JSON.stringify(univ3slippageMaps[startBlock]));
    // console.log('-----------------------');
    // console.log(JSON.stringify(univ3slippageMapsCombined[startBlock]));

    // const resultMulti = getAverageLiquidityForInterval(base, quote, startBlock, endBlock, ['uniswapv2','uniswapv3'], false);
    // console.log(resultMulti[500]);
    // const result = getAverageLiquidityForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], false);
    // console.log(result[500]);
    // const resultJumps = getAverageLiquidityForInterval(base, quote, startBlock, endBlock, ['uniswapv3'], true);
    // console.log(resultJumps[500]);
    // const resultJumpsMulti = getAverageLiquidityForInterval(base, quote, startBlock, endBlock, ['uniswapv2','uniswapv3'], true);
    // console.log(resultJumpsMulti[500]);

    const avg = getAverageLiquidityForInterval('MANA', 'USDC', 17878273, 17928316, ['uniswapv3'], true);
    console.log(avg);
    // console.log(slippageMaps[startBlock], univ2slippageMaps[startBlock], univ3slippageMaps[startBlock], curveSlippageMaps[startBlock]);
}

// testVolatility();
// testLiquidity();

module.exports = { getParkinsonVolatilityForInterval, getSlippageMapForInterval, getAverageLiquidityForInterval };