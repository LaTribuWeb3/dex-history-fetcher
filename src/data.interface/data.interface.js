////////////////////////////////////////
/////// THIS IS THE DATA INTERFACE /////
// IT ALLOWS EASY ACCESS TO CSV DATA ///
/// IT SHOULD BE THE ONLY THING USED ///
/// TO ACCESS THE DATA GENERATED BY ////
//////////// BY THE FETCHERS ///////////

const path = require('path');
const fs = require('fs');
const { fnName } = require('../utils/utils');
const { computeParkinsonVolatility } = require('../utils/volatility');

const PIVOTS = ['USDC', 'WETH', 'WBTC'];
const ALL_PLATFORMS = ['uniswapv2', 'uniswapv3', 'curve'];
const DATA_DIR = process.cwd() + '/data';



/**
 * Compute the parkinson's volatility for a pair
 * If 'platforms' is undefined, will find the volatility across all platforms (find the best one?)
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {number} daysToAvg the number of days the interval spans
 * 
 */
function getParkinsonVolatilityForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, daysToAvg) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    const label = `${fnName()}[${fromSymbol}/${toSymbol}] [${fromBlock}-${toBlock}] [${platforms.join(',')}`;

    console.log(`${label}: getting data for all platforms, will keep the one with the most data`);
    let selectedData = undefined;
    let selectedPlatform = undefined;
    for(const platform of platforms) {
        const unifiedData = getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock);
        if(!unifiedData) {
            console.log(`${label}: could not find data on platform ${platform}`);
        } else {
            if(!selectedData || Object.keys(selectedData).length < Object.keys(unifiedData).length) {
                selectedData = structuredClone(unifiedData);
                selectedPlatform = platform;
            }
        }
    }

    if(!selectedData || !selectedPlatform) {
        throw new Error(`${label}: Could not find data anywhere`);
    }

    console.log(`${label}: selected data from ${selectedPlatform}`);
    // generate the priceAtBlock object
    const priceAtBlock = {};
    for(const [blockNumber, unifiedData] of Object.entries(selectedData)) {
        priceAtBlock[blockNumber] = unifiedData.price;
    }

    return computeParkinsonVolatility(priceAtBlock, fromSymbol, toSymbol, fromBlock, toBlock, daysToAvg);
}

/**
 * Get the slippage map for a pair
 * @param {string} fromSymbol 
 * @param {string} toSymbol 
 * @param {number} fromBlock 
 * @param {number} toBlock 
 * @param {string[] | undefined} platforms 
 * @param {bool} withJumps 
 */
async function getSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms, withJumps) {
    if(!platforms || platforms.length == 0) {
        platforms = ALL_PLATFORMS;
    }

    if(platforms.some(_ => !ALL_PLATFORMS.includes(_))) {
        throw new Error(`At least one platform request is not known: ${platforms.join(',')}`);
    }

    // if(withJumps) {
    //     return await getCombinedSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
    // } else {
    //     return await getSimpleSlippageMapForInterval(fromSymbol, toSymbol, fromBlock, toBlock, platforms);
    // }
}

function getUnifiedDataForInterval(platform, fromSymbol, toSymbol, fromBlock, toBlock) {
    // try to find the data
    const filename = `${fromSymbol}-${toSymbol}-unified-data.csv`;
    const fullFilename = path.join(DATA_DIR, 'precomputed', platform, filename);
    console.log(`${fnName()}: searching file ${fullFilename}`);
    if(!fs.existsSync(fullFilename)) {
        console.log(`Could not find file ${fullFilename}`);
        return undefined;
    }

    console.log(`${fnName()}: ${fullFilename} found! Extracting data since ${fromBlock} to ${toBlock}`);
    
    const fileContent = fs.readFileSync(fullFilename, 'utf-8').split('\n');
    const unifiedData = {};
    for(let i = 1; i < fileContent.length - 1; i++) {
        const blockNumber = Number(fileContent[i].split(',')[0]);
        if(blockNumber < fromBlock) {
            continue;
        }

        if(blockNumber > toBlock) {
            break;
        }

        const data = extractDataFromUnifiedLine(fileContent[i]);
        unifiedData[data.blockNumber] = {
            price: data.price,
            slippageMap: data.slippageMap
        };
    }

    return unifiedData;
}

function extractDataFromUnifiedLine(line) {
    const splt = line.split(',');
    const blockNumber = splt[0];
    const price = splt[1];
    const slippageMapJson = line.replace(`${blockNumber},${price},`, '');
    const slippageMap = JSON.parse(slippageMapJson);

    return {
        blockNumber: Number(blockNumber),
        price: Number(price),
        slippageMap: slippageMap
    };
}

module.exports = { getParkinsonVolatilityForInterval, getSlippageMapForInterval };